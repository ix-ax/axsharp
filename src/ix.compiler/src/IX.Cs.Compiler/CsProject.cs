// Ix.Compiler.Cs
// Copyright (c) 2023 Peter Kurhajec (PTKu), MTS,  and Contributors. All Rights Reserved.
// Contributors: https://github.com/ix-ax/ix/graphs/contributors
// See the LICENSE file in the repository root for more information.
// https://github.com/ix-ax/ix/blob/master/LICENSE
// Third party licenses: https://github.com/ix-ax/ix/blob/master/notices.md

using System.Reflection;
using System.Xml.Linq;
using Ix.Compiler.Cs.Exceptions;
using Microsoft.CodeAnalysis.CSharp;
using NuGet.Configuration;
using NuGet.Packaging;
using NuGet.Versioning;
using Polly;

namespace Ix.Compiler;

/// <summary>
///     Provides information about CSharp project from csproj file.
/// </summary>
public class CsProject : ITargetProject
{
    /// <summary>
    /// Create new instance of the <see cref="CsProject" />.
    /// </summary>
    /// <param name="ixProject"></param>
    public CsProject(IxProject ixProject)
    {
        IxProject = ixProject;
        ProjectRootNamespace = MakeValidIdentifier(ixProject.AxProject.ProjectInfo.Name);
    }

    private IxProject IxProject { get; }


    /// <summary>
    ///     Gets associated IxProject file.
    /// </summary>
    public string IxProjectFile => Path.Combine(IxProject.OutputFolder,
        $"{MakeValidFileName(IxProject.AxProject.ProjectInfo.Name)}.csproj");


    /// <summary>
    ///     Gets project's root namespace. In this namespace will be enclosed all types generated by the builders.
    /// </summary>
    public string ProjectRootNamespace { get; }

    private static string MakeValidFileName(string name)
    {
        var fileName = name;
        foreach (var c in Path.GetInvalidFileNameChars()) fileName = fileName.Replace(c, '_');

        fileName = fileName.Replace('@', '_');

        return fileName;
    }

    private static string MakeValidIdentifier(string name)
    {
        var fileName = string.Empty;

        if (SyntaxFacts.IsIdentifierPartCharacter(name.FirstOrDefault())) fileName = $"{name.FirstOrDefault()}";

        for (var i = 1; i < name.Length; i++)
        {
            var c = name[i];
            fileName = SyntaxFacts.IsIdentifierPartCharacter(c) ? $"{fileName}{c}" : $"{fileName}{'_'}";
        }

        return fileName;
    }

    private static string GetExecutingAssemblyPath()
    {       
        var assemblyPath = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
        return assemblyPath!;
    }


    private void EnsureCsProjFile()
    {
        if (IxProject.AxProject.ProjectInfo.Name != null)
        {
            var expectedCsProjFile = Path.Combine(IxProject.OutputFolder,
                $"{MakeValidFileName(IxProject.AxProject.ProjectInfo.Name)}.csproj");

            var defaultCsProjectWhenNotProvidedByTemplate =
                $@"<Project Sdk=""Microsoft.NET.Sdk"">
	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include=""Ix.Abstractions"" Version=""{GitVersionInformation.SemVer}"" />
		<PackageReference Include=""Ix.Connector"" Version=""{GitVersionInformation.SemVer}"" />
	</ItemGroup>

	<ItemGroup>
		<Compile Include="".g\**"" />
	</ItemGroup>
</Project>";


            Policy
                .Handle<IOException>()
                .WaitAndRetry(5, a => TimeSpan.FromMilliseconds(500))
                .Execute(() =>
                {
                    if (!File.Exists(expectedCsProjFile))
                    {
                        using (var swr = new StreamWriter(expectedCsProjFile))
                        {
                            swr.Write(defaultCsProjectWhenNotProvidedByTemplate);
                        }
                    }
                });
        }
    }

    #region Dependencies

    private static readonly string NugetDir =
        SettingsUtility.GetGlobalPackagesFolder(Settings.LoadDefaultSettings(null));


    /// <inheritdoc />
    public void ProvisionProjectStructure()
    {
        EnsureCsProjFile();
    }


    /// <inheritdoc />
    public string GetMetaDataFolder => Path.Combine(IxProject.OutputFolder, ".meta");

    /// <summary>
    ///     Retrieves references from csproj file associated with given project.
    /// </summary>
    /// <returns>List of references.</returns>
    public IEnumerable<IReference> LoadReferences()
    {
        var directDependencies = GetDirectDependencies(IxProjectFile).ToList();

        var referenceDependencies = new List<IReference>();

        foreach (var dependency in directDependencies)
            GetReferenceDependencies(dependency, referenceDependencies);

        return DistinctBy(referenceDependencies, p => p.ReferencePath);
    }

    private static string FileDirectory(string path)
    {
        return new FileInfo(path).Directory!.FullName;
    }

    private static IEnumerable<IReference> GetDirectDependencies(string projectFile)
    {
        var projectPath = projectFile;

        if (!File.Exists(projectPath)) return new List<IReference>();

        try
        {
            var csproj = XDocument.Load(projectPath);
            var csprojDir = FileDirectory(projectFile);
            var nugets = PackageReferences(csproj, projectFile);
            var projects = ProjectReferences(csproj, csprojDir);
            return nugets.Concat(projects);
        }
        catch (Exception ex)
        {
            throw new FailedGettingPackageReferenceException(
                $"Failed to retrieve package reference from project '{projectPath}'", ex);
        }
    }

    private static IEnumerable<TSource> DistinctBy<TSource, TKey>
        (IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
    {
        var seenKeys = new HashSet<TKey>();
        foreach (var element in source)
            if (seenKeys.Add(keySelector(element)))
                yield return element;
    }

    private IEnumerable<IReference> GetReferenceDependencies(IReference reference,
        List<IReference>? dependencies = null, int depth = 0)
    {
        dependencies ??= new List<IReference>();

        dependencies.Add(reference);

        switch (reference)
        {
            case PackageReference r:
                var existingPackagesPath = PackageReferenceNugetPath(r);

                if (Directory.Exists(existingPackagesPath))
                {
                    var package = Directory.GetFiles(existingPackagesPath).Where(p => p.EndsWith(".nupkg"))
                        .Select(a => new PackageArchiveReader(a)).FirstOrDefault();

                    if (package != null)
                        foreach (var dependency in package.GetPackageDependencies())
                        {
                            var deps = dependency.Packages.Select(p => new PackageReference(p));
                            var uniqueDependencies = new List<IReference>();
                            foreach (var dp in deps)
                                if (!dependencies.Exists(p => p.ReferencePath == dp.ReferencePath))
                                {
                                    uniqueDependencies.Add(dp);
                                    dependencies.Add(dp);
                                }


                            foreach (var dep in uniqueDependencies)
                                GetReferenceDependencies(dep, dependencies, depth);
                        }
                }

                break;
            case ProjectReference r:
                foreach (var dep in GetProjectDependencies(r))
                    GetReferenceDependencies(dep, dependencies, depth);
                break;
        }


        return dependencies;
    }

    private static IEnumerable<IReference> GetProjectDependencies(ProjectReference project)
    {
        try
        {
            var csproj = XDocument.Load(project.ProjectFilePath);
            var csprojDir = FileDirectory(project.ProjectFilePath);
            var nugets = PackageReferences(csproj, project.ProjectFilePath);
            var projects = ProjectReferences(csproj, csprojDir);
            project.References = nugets.Concat(projects);
            return project.References;
        }
        catch (Exception ex)
        {
            throw new FailedToRetrievePackageReferenceException(
                $"Failed to retrieve package reference from project '{project.ProjectFilePath}'",
                ex);
        }
    }

    private static IEnumerable<IReference> PackageReferences(XDocument csproj, string projectFile)
    {
        return csproj
            .Root!
            .Elements("ItemGroup")
            .SelectMany(ig => ig.Elements("PackageReference"))
            .Select(pr => PackageReference.CreateFromReferenceNode(pr, projectFile));
    }

    private static string PackageReferenceNugetPath(PackageReference package)
    {
        return Path.Combine(NugetDir, package.Name, GetBestMatchedVersion(package.Name, package.Version));
    }

    internal static string GetBestMatchedVersion(string packageName, string packageVersion)
    {
        try
        {
            var packageDirectory = Path.Combine(NugetDir, packageName);

            if (Directory.Exists(packageDirectory))
            {
                var packages = Directory.EnumerateDirectories(packageDirectory).Select(p => new DirectoryInfo(p))
                    .Select(v => new NuGetVersion(v.Name));

                var versionRange = VersionRange.Parse(packageVersion);
                var bestMatch = versionRange.FindBestMatch(packages);

                if (bestMatch != null) return bestMatch.ToNormalizedString();
            }

            return packageVersion;
        }
        catch (Exception e)
        {
            throw new FailedToDeterminePackageVersion($"Unable to determine package version of '{packageName}::{packageVersion}'", e);
        }
       
    }

    private static IEnumerable<IReference> ProjectReferences(XDocument csproj, string directory)
    {
        return csproj
            .Root!
            .Elements("ItemGroup")
            .SelectMany(ig => ig.Elements("ProjectReference"))
            .Select(pr => new ProjectReference(directory, pr.Attribute("Include").Value.Replace("\\",Path.DirectorySeparatorChar.ToString())));
    }

    #endregion
}