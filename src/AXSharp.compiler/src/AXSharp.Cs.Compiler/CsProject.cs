// AXSharp.Compiler.Cs
// Copyright (c) 2023 Peter Kurhajec (PTKu), MTS,  and Contributors. All Rights Reserved.
// Contributors: https://github.com/ix-ax/axsharp/graphs/contributors
// See the LICENSE file in the repository root for more information.
// https://github.com/ix-ax/axsharp/blob/dev/LICENSE
// Third party licenses: https://github.com/ix-ax/axsharp/blob/master/notices.md

using System.Diagnostics;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using AXSharp.Compiler.Cs.Exceptions;
using Microsoft.CodeAnalysis.CSharp;
using NuGet.Configuration;
using NuGet.Packaging;
using NuGet.Versioning;
using Polly;

namespace AXSharp.Compiler;

/// <summary>
///     Provides information about CSharp project from csproj file.
/// </summary>
public class CsProject : ITargetProject
{
    /// <summary>
    /// Create new instance of the <see cref="CsProject" />.
    /// </summary>
    /// <param name="AXSharpProject"></param>
    public CsProject(AXSharpProject AXSharpProject)
    {
        AxSharpProject = AXSharpProject;
        ProjectRootNamespace = MakeValidIdentifier(AXSharpProject.AxProject.ProjectInfo.Name);
    }

    private AXSharpProject AxSharpProject { get; }


    /// <summary>
    ///     Gets associated IxProject file.
    /// </summary>
    public string IxProjectFile => Path.Combine(AxSharpProject.OutputFolder,
        $"{MakeValidFileName(AxSharpProject.AxProject.ProjectInfo.Name)}.csproj");


    /// <summary>
    ///     Gets project's root namespace. In this namespace will be enclosed all types generated by the builders.
    /// </summary>
    public string ProjectRootNamespace { get; }

    private static string MakeValidFileName(string name)
    {
        var fileName = name;
        //foreach (var c in Path.GetInvalidFileNameChars()) fileName = fileName.Replace(c, '_');
        fileName = MakeValidIdentifier(fileName);

        fileName = fileName.Replace('@', '_');

        return fileName;
    }

    private static string MakeValidIdentifier(string name)
    {
        var fileName = string.Empty;

        if (SyntaxFacts.IsIdentifierPartCharacter(name.FirstOrDefault())) fileName = $"{name.FirstOrDefault()}";

        for (var i = 1; i < name.Length; i++)
        {
            var c = name[i];
            fileName = SyntaxFacts.IsIdentifierPartCharacter(c) ? $"{fileName}{c}" : $"{fileName}{'_'}";
        }

        return fileName;
    }

    private static string GetExecutingAssemblyPath()
    {       
        var assemblyPath = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location);
        return assemblyPath!;
    }


    private void EnsureCsProjFile()
    {
        if (AxSharpProject.AxProject.ProjectInfo.Name != null)
        {
            string expectedCsProjFileFullPath = string.Empty;
            string expectedCsProjFile = string.Empty;
            if (string.IsNullOrEmpty(this.AxSharpProject.CompilerOptions?.ProjectFile))
            {
                expectedCsProjFile = $"{MakeValidFileName(AxSharpProject.AxProject.ProjectInfo.Name)}.csproj";
                expectedCsProjFileFullPath = Path.Combine(AxSharpProject.OutputFolder,
                    expectedCsProjFile);
            }
            else
            {
                expectedCsProjFile = this.AxSharpProject.CompilerOptions.ProjectFile;
                expectedCsProjFileFullPath = Path.Combine(AxSharpProject.OutputFolder,
                    expectedCsProjFile);
            }

            var compilerOptions = this.AxSharpProject.CompilerOptions;
            if (compilerOptions != null)
            {
                compilerOptions.ProjectFile = expectedCsProjFile;
                AXSharpConfig.UpdateAndGetAXSharpConfig(AxSharpProject.AxProject.ProjectFolder, compilerOptions);
            }

            var defaultCsProjectWhenNotProvidedByTemplate =
                $@"<Project Sdk=""Microsoft.NET.Sdk"">
	<PropertyGroup>
		<TargetFramework>net7.0</TargetFramework>
		<ImplicitUsings>enable</ImplicitUsings>
		<Nullable>enable</Nullable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include=""AXSharp.Abstractions"" Version=""{GitVersionInformation.SemVer}"" />
		<PackageReference Include=""AXSharp.Connector"" Version=""{GitVersionInformation.SemVer}"" />
	</ItemGroup>

	<ItemGroup>
		<Compile Include="".g\**"" />
	</ItemGroup>
</Project>";


            Policy
                .Handle<IOException>()
                .WaitAndRetry(5, a => TimeSpan.FromMilliseconds(500))
                .Execute(() =>
                {
                    if (!File.Exists(expectedCsProjFileFullPath))
                    {
                        using (var swr = new StreamWriter(expectedCsProjFileFullPath))
                        {
                            swr.Write(defaultCsProjectWhenNotProvidedByTemplate);
                        }
                    }
                });
        }
    }

    #region Dependencies

    private static readonly string NugetDir =
        SettingsUtility.GetGlobalPackagesFolder(Settings.LoadDefaultSettings(null));


    /// <inheritdoc />
    public void ProvisionProjectStructure()
    {
        EnsureCsProjFile();
    }

    public void GenerateResources()
    { 
        var a =  @$"
using System.Reflection;
using AXSharp.Connector.Localizations;

namespace {this.ProjectRootNamespace}
{{
    public sealed class PlcTranslator : Translator
    {{
        private static readonly PlcTranslator instance = new PlcTranslator();

        public static PlcTranslator Instance
        {{
            get
            {{
                return instance;
            }}
        }}

        private PlcTranslator() 
        {{
            var defaultResourceType = Assembly.GetAssembly(typeof({this.ProjectRootNamespace}.PlcTranslator))
                .GetType(""{this.ProjectRootNamespace}.Resources.PlcStringResources"");
            this.SetLocalizationResource(defaultResourceType);
        }}
    }}
}}";

        using var swr = new StreamWriter(Path.Combine(this.AxSharpProject.OutputFolder, ".g", "PlcResources.g.cs"));
        swr.Write(a);
    }


    /// <inheritdoc />
    public string GetMetaDataFolder => Path.Combine(AxSharpProject.OutputFolder, ".meta");

    public static string GetRelativePath(string fromPath, string toPath)
    {
        var fromUri = new Uri(fromPath);
        var toUri = new Uri(toPath);

        if (fromUri.Scheme != toUri.Scheme)
        {
            // Handle different schemes. 
            // You could throw an exception here or return the `toPath` as is, 
            // depending on your needs.
            return toPath;
        }

        Uri relativeUri = fromUri.MakeRelativeUri(toUri);
        var relativePath = Uri.UnescapeDataString(relativeUri.ToString());

        return relativePath.Replace('/', System.IO.Path.DirectorySeparatorChar);
    }

    private static bool ProjectReferenceExists(string mainProjectPath, string referenceProjectPath)
    {
        var xDocument = XDocument.Load(mainProjectPath);
        
        // Using XPath to search for the ProjectReference with a specific Include path
        var projectReferenceElements = xDocument.XPathSelectElements($"//ProjectReference[@Include='{referenceProjectPath}']");

        return projectReferenceElements.Any();
    }

    private static void AddProjectReference(string mainProjectPath, string referenceProjectPath)
    {
        if (ProjectReferenceExists(mainProjectPath, referenceProjectPath))
            return;

        using (var process = new Process())
        {
            process.StartInfo.FileName = "dotnet";
            process.StartInfo.Arguments = $"add \"{mainProjectPath}\" reference \"{referenceProjectPath}\"";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;

            process.OutputDataReceived += (sender, data) => { if (!string.IsNullOrEmpty(data.Data)) { Console.WriteLine(data.Data); } };
            process.ErrorDataReceived += (sender, data) => { if (!string.IsNullOrEmpty(data.Data)) { Console.WriteLine(data.Data); } };

            process.Start();

            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            process.WaitForExit();
        }
    }

    private static bool PackageReferenceExists(string projectFilePath, string packageName, string version)
    {
        var xDocument = XDocument.Load(projectFilePath);

        var package
            = PackageReference.GetVersionFromCentralPackageManagement(projectFilePath)?
                .FirstOrDefault(p => p.include == packageName);

        var hasWithVersion = xDocument.XPathSelectElements($"//PackageReference[@Include='{packageName}' and @Version='{version}']").Any();

        var hasVersionInCentralPackageManagement = (xDocument.XPathSelectElements(
            $"//PackageReference[@Include='{packageName}']").Any() && package != null && package?.version == version);

        return hasWithVersion || hasVersionInCentralPackageManagement;

    }

    private static void AddNuGetPackageReference(string projectPath, string packageName, string version = null)
    {

        if (PackageReferenceExists(projectPath, packageName, version))
            return;

        using (var process = new Process())
        {
            process.StartInfo.FileName = "dotnet";
            process.StartInfo.Arguments = $"add \"{projectPath}\" package {packageName}" + (string.IsNullOrEmpty(version) ? "" : $" --version {version}");
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;

            process.OutputDataReceived += (sender, data) => { if (!string.IsNullOrEmpty(data.Data)) { Console.WriteLine(data.Data); } };
            process.ErrorDataReceived += (sender, data) => { if (!string.IsNullOrEmpty(data.Data)) { Console.WriteLine(data.Data); } };

            process.Start();

            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            process.WaitForExit();
        }
    }

    /// <summary>
    /// Installs dependencies to the companion twin project from using dependencies from `apax.yml` file of a given AX project.
    /// </summary>
    /// <param name="dependencies"></param>
    public void InstallAXSharpDependencies(IEnumerable<object> dependencies)
    {
        var compilerOptions = this.AxSharpProject.CompilerOptions;
        if (compilerOptions != null && compilerOptions.NoDependencyUpdate) return;

        var compilerOptionsProjectFile = this.AxSharpProject.CompilerOptions?.ProjectFile;

        if (compilerOptionsProjectFile != null)
        {
            var dependent = Path.Combine(this.AxSharpProject.OutputFolder, compilerOptionsProjectFile);
            foreach (var dependency in dependencies)
            {
               
                switch (dependency)
                {
                    case CompanionInfo package:
                        AddNuGetPackageReference(dependent, package.Id, package.Version);
                        break;
                    case AXSharpConfig project:
                        var projectPath = Path.GetFullPath(Path.Combine(project.AxProjectFolder, project.OutputProjectFolder, project.ProjectFile));
                        AddProjectReference(dependent, GetRelativePath(dependent, projectPath));
                        break;
                }
            }
        }
    }

    /// <summary>
    ///     Retrieves references from csproj file associated with given project.
    /// </summary>
    /// <returns>List of references.</returns>
    public IEnumerable<IReference> LoadReferences()
    {
        var directDependencies = GetDirectDependencies(IxProjectFile).ToList();

        var referenceDependencies = new List<IReference>();

        foreach (var dependency in directDependencies)
            GetReferenceDependencies(dependency, referenceDependencies);

        return DistinctBy(referenceDependencies, p => p.ReferencePath);
    }

    private static string FileDirectory(string path)
    {
        return new FileInfo(path).Directory!.FullName;
    }

    private static IEnumerable<IReference> GetDirectDependencies(string projectFile)
    {
        var projectPath = projectFile;

        if (!File.Exists(projectPath)) return new List<IReference>();

        try
        {
            var csproj = XDocument.Load(projectPath);
            var csprojDir = FileDirectory(projectFile);
            var nugets = PackageReferences(csproj, projectFile);
            var projects = ProjectReferences(csproj, csprojDir);
            return nugets.Concat(projects);
        }
        catch (Exception ex)
        {
            throw new FailedGettingPackageReferenceException(
                $"Failed to retrieve package reference from project '{projectPath}'", ex);
        }
    }

    private static IEnumerable<TSource> DistinctBy<TSource, TKey>
        (IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
    {
        var seenKeys = new HashSet<TKey>();
        foreach (var element in source)
            if (seenKeys.Add(keySelector(element)))
                yield return element;
    }

    private IEnumerable<IReference> GetReferenceDependencies(IReference reference,
        List<IReference>? dependencies = null, int depth = 0)
    {
        dependencies ??= new List<IReference>();

        dependencies.Add(reference);

        switch (reference)
        {
            case PackageReference r:
                var existingPackagesPath = PackageReferenceNugetPath(r);

                if (Directory.Exists(existingPackagesPath))
                {
                    var package = Directory.GetFiles(existingPackagesPath).Where(p => p.EndsWith(".nupkg"))
                        .Select(a => new PackageArchiveReader(a)).FirstOrDefault();

                    if (package != null)
                        foreach (var dependency in package.GetPackageDependencies())
                        {
                            var deps = dependency.Packages.Select(p => new PackageReference(p));
                            var uniqueDependencies = new List<IReference>();
                            foreach (var dp in deps)
                                if (!dependencies.Exists(p => p.ReferencePath == dp.ReferencePath))
                                {
                                    uniqueDependencies.Add(dp);
                                    dependencies.Add(dp);
                                }


                            foreach (var dep in uniqueDependencies)
                                GetReferenceDependencies(dep, dependencies, depth);
                        }
                }

                break;
            case ProjectReference r:
                foreach (var dep in GetProjectDependencies(r))
                    GetReferenceDependencies(dep, dependencies, depth);
                break;
        }


        return dependencies;
    }

    private static IEnumerable<IReference> GetProjectDependencies(ProjectReference project)
    {
        try
        {
            var csproj = XDocument.Load(project.ProjectFilePath);
            var csprojDir = FileDirectory(project.ProjectFilePath);
            var nugets = PackageReferences(csproj, project.ProjectFilePath);
            var projects = ProjectReferences(csproj, csprojDir);
            project.References = nugets.Concat(projects);
            return project.References;
        }
        catch (Exception ex)
        {
            throw new FailedToRetrievePackageReferenceException(
                $"Failed to retrieve package reference from project '{project.ProjectFilePath}'",
                ex);
        }
    }

    private static IEnumerable<IReference> PackageReferences(XDocument csproj, string projectFile)
    {
        return csproj
            .Root!
            .Elements("ItemGroup")
            .SelectMany(ig => ig.Elements("PackageReference"))
            .Select(pr => PackageReference.CreateFromReferenceNode(pr, projectFile));
    }

    private static string PackageReferenceNugetPath(PackageReference package)
    {
        return Path.Combine(NugetDir, package.Name, GetBestMatchedVersion(package.Name, package.Version));
    }

    internal static string GetBestMatchedVersion(string packageName, string packageVersion)
    {
        try
        {
            var packageDirectory = Path.Combine(NugetDir, packageName);

            if (Directory.Exists(packageDirectory))
            {
                var packages = Directory.EnumerateDirectories(packageDirectory).Select(p => new DirectoryInfo(p))
                    .Select(v => new NuGetVersion(v.Name));

                var versionRange = VersionRange.Parse(packageVersion);
                var bestMatch = versionRange.FindBestMatch(packages);

                if (bestMatch != null) return bestMatch.ToNormalizedString();
            }

            return packageVersion;
        }
        catch (Exception e)
        {
            throw new FailedToDeterminePackageVersion($"Unable to determine package version of '{packageName}::{packageVersion}'", e);
        }
       
    }

    private static IEnumerable<IReference> ProjectReferences(XDocument csproj, string directory)
    {
        return csproj
            .Root!
            .Elements("ItemGroup")
            .SelectMany(ig => ig.Elements("ProjectReference"))
            .Select(pr => new ProjectReference(directory, pr.Attribute("Include")!.Value.Replace("\\",Path.DirectorySeparatorChar.ToString())));
    }

    #endregion

    static string GetPackageId(string csprojPath)
    {
        XDocument xDocument = XDocument.Load(csprojPath);

        var packageIdElement = xDocument.Descendants("PackageId").FirstOrDefault();

        if (packageIdElement != null)
        {
            return packageIdElement.Value;
        }

        // If PackageId element is not found, default to the project's name
        return Path.GetFileNameWithoutExtension(csprojPath);
    }

    public void GenerateCompanionData()
    {
        var compilerOptions = this.AxSharpProject.CompilerOptions;
        if (compilerOptions != null)
        {
            if (compilerOptions.ProjectFile != null)
            {
                var packageId = GetPackageId(Path.Combine(this.AxSharpProject.OutputFolder,
                    compilerOptions.ProjectFile));

                CompanionInfo.ToFile(new CompanionInfo() { Id = packageId, Version = this.AxSharpProject.AxProject.ProjectInfo.Version }, Path.Combine(this.AxSharpProject.AxProject.ProjectFolder, CompanionInfo.COMPANIONS_FILE_NAME));
            }
        }
    }
}